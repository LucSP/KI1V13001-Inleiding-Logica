%by Maarten Burger, Alexander Apers, and Jos Zuiderwijk
\chapter{Chapter 10. Tableaux for First-Order Logic}

\section*{10.8 Exercises}

\begin{itemize}
\item[10.8.1]
    \begin{enumerate}[(a)]
      \item %
        \begin{prooftree}
          {%
            line numbering=false,
            for tree={s sep'=10mm},
            single branches=true,
            close with=\xmark
          }
          [\forall xP(x), grouped
            [\neg \forall yP(y), grouped
                [\exists y\neg P(y)
                    [\neg P(p)
                        [P(p), close]
                    ]
                ]
            ]
          ]
        \end{prooftree}

      \item%
        \begin{prooftree}
        {%
          line numbering=false,
          for tree={s sep'=10mm},
          single branches=true,
          close with=\xmark
        }
        [{\exists x\exists yS(x,y)}, grouped
            [{\neg \exists y\exists xS(x,y)}, grouped
                [{\exists yS(p_1, y)}
                    [{S(p_1,p_2)}
                        [{\forall y\neg \exists xS(x,y)}
                            [{\neg\exists xS(x,p_2)}
                                [{\forall \neg S(x,p_2)}
                                    [{\neg S(p_1, p_2)}, close]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]
      \end{prooftree}

      \item %
        \begin{prooftree}
          {%
            line numbering=false,
            for tree={s sep'=10mm},
            single branches=true,
            close with=\xmark
          }
          [{\neg \exists xP(x)}, grouped
            [{\neg \forall x(P(x)\to Q(x))}, grouped
                [{\exists x\neg (P(x)\to Q(x))}
                    [{\neg (P(p)\to Q(p))}
                        [P(p)
                            [\neg Q(p)
                                [\forall x\neg P(x)
                                    [\neg P(p), close ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]
      \end{prooftree}

      \item %
        \begin{prooftree}
          {%
            line numbering=false,
            for tree={s sep'=10mm},
            single branches=true,
            close with=\xmark
          }
          [{\forall xP(x)}, grouped
            [{\neg \forall x(Q(x)\to P(x)\lor R(x))}, grouped
                [{\exists x\neg (Q(x)\to P(x)\lor R(x))}
                    [{\neg (Q(p)\to P(p)\lor R(p))}
                        [Q(p)
                            [\neg (P(p)\lor R(p))
                                [\neg P(p)
                                    [\neg R(p)
                                        [P(p), close ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]
      \end{prooftree}

    \end{enumerate}

\item[10.8.2]
  \begin{enumerate}[(a)]
    \item %
      \begin{prooftree}
        {%
          line numbering=false,
          for tree={s sep'=10mm},
          single branches=true,
          close with=\xmark
        }
        [{\forall x(P(x)\to Q(x))}, grouped
            [{\exists x\neg P(x)}, grouped
                [{\neg \forall x\neg Q(x)}, grouped
                    [{\neg P(p_1)}
                        [P(p_1)\to Q(p_1)
                            [\exists x\neg\neg Q(x)
                                [\neg\neg Q(p_2)
                                    [Q(p_2)
                                        [P(p_2)\to Q(p_2)
                                            [\neg P(p_1)
                                                [\neg P(p_2)]
                                                    [Q(p_2)]
                                            ]
                                            [Q(p_1)
                                                [\neg P(p_2)]
                                                [Q(p_2)]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]
      \end{prooftree}

      Call the leftmost branch $B$.
      Then we get $\mathcal{M}_B$ with 
      $D^{\mathcal{M}_B}=\{p_1, p_2\}$
      as well as
      $P^{\mathcal{M}_B}=\emptyset$
      and $Q^{\mathcal{M}_B}=\{p_2\}$.

    \item %
      \begin{prooftree}
        {
          line numbering=false,
          for tree={s sep'=10mm},
          single branches=true,
          close with=\xmark
        }
        [{\forall xP(x)\to \forall yQ(y)}, grouped
            [{\neg\forall x(P(x)\to \forall yQ(y))}, grouped
                [\exists x\neg (P(x)\to \forall yQ(y))
                    [\neg (P(p)\to \forall yQ(y))
                        [P(p)
                            [\neg \forall yQ(y)
                                [\exists y\neg Q(y)
                                    [\neg Q(q)
                                        [\neg \forall xP(x)
                                            [\exists x\neg P(x)
                                                [\neg P(r) ]
                                            ]
                                        ]
                                        [\forall yQ(y)
                                            [Q(q), close]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]
      \end{prooftree}

      Let $B$ be the open branch.
      We get $\mathcal{M}_B$ with
      $D^{\mathcal{M}_B}=\{p, q, r\}$
      as well as
      $P^{\mathcal{M}_B}=\{p\}$
      and
      $Q^{\mathcal{M}_B}=\emptyset$.

    \item %Here goes (c)

      \begin{prooftree}
        {%
          line numbering=false,
          for tree={s sep'=10mm},
          single branches=true,
          close with=\xmark
        }
        [{\exists x(P(x)\to \forall yQ(y))}, grouped
          [{\neg (\exists xP(x)\to \forall yQ(y))}, grouped
            [\exists xP(x)
              [\neg \forall yQ(y)
                [\exists y\neg Q(y)
                  [{P(p)}
                    [{\neg Q(q)}
                      [{P(r)\to \forall yQ(y)}
                        [{\neg P(r)}]
                          [{\forall y Q(y)}
                            [{Q(p)}
                              [{Q(q)}, close]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
      \end{prooftree}

      Call the open branch $B$.
      We get the following countermodel:
      \begin{itemize}
        \item $D^{\mathcal{M}_{B}}=\{p,q,r\}$
        \item $P^{\mathcal{M}_{B}}=\{p\}$
        \item $Q^{\mathcal{M}_{B}}=\emptyset$
      \end{itemize}

    \item %
      \begin{prooftree}
        {%
          line numbering=false,
          for tree={s sep'=10mm},
          single branches=true,
          close with=\xmark
        }
        [{\forall x\exists yS(x,y)}, grouped
          [{\neg\exists xS(x,x)}, grouped
            [{\forall x\neg S(x,x)}
              [{\exists yS(p_1, y)}
                [{\neg S(p_1, p_1)}
                  [{S(p_1, p_2)}
                    [{\exists yS(p_2, y)}
                      [{\neg S(p_2, p_2)}
                        [{S(p_2, p_3)}
                          [\vdots]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      \end{prooftree}

      It's relatively straight-forward to see that the tableau will be infinite:
      the universal quantifier in
      $\forall x\exists y S(x,y)$
      needs to be instantiated for each new parameter but itself generates an existential quantifier
      $\exists y S(p_{i}, y)$,
      which forces us to introduce a new parameter,
      and so on.

      At the same time,
      the tableau will not be closed,
      since the only negated atoms are going to be of the form
      $\neg S(p_{i}, p_{i})$
      coming from the universal quantifier $\forall x\neg S(x,x)$; and the only un-negated atoms come from our existential quantifiers
      $\exists y S(p_{i}, y)$,
      which can never give us a formula of the form $S(p_{i}, p_{i})$.

      As our countermodel,
      we get $\mathcal{M}_B$ with
      $D^{\mathcal{M}_B}=\{p_1, p_2, \mathellipsis\}$
      and
      $S^{\mathcal{M}_B}=\{\langle p_1, p_2\rangle, \langle p_2, p_3\rangle, \mathellipsis\}$.

     A finite countermodel for the same inference is
      $D^{\mathcal{M}_B}=\{p_1, p_2\}$
      and
      $S^{\mathcal{M}_B}=\{\langle p_1, p_2\rangle, \langle p_2, p_1\rangle \}$.

    \item %
      \begin{prooftree}
      {%
        line numbering=false,
        for tree={s sep'=10mm},
        single branches=true,
        close with=\xmark
      }
      [{\exists x\neg\exists yS(x,y)}, grouped
        [{\neg \exists x\forall yS(x,y)}, grouped
          [{\neg\exists yS(p_1, y)}
            [{\forall y\neg S(p_1, y)}
              [{\neg S(p_1, p_1)}
                [{\forall x\neg \forall yS(x,y)}
                  [{\neg\forall yS(p_1, y)}
                    [{\exists y\neg S(p_1, y)}
                      [{\neg S(p_1, p_2)}
                        [{\neg S(p_1, p_2)}
                          [{\neg \forall yS(p_2, y)}
                            [{\exists y\neg S(p_2, y)}
                              [{\neg S(p_2, p_3)}
                                [{\neg S(p_1, p_3)}
                                  [\vdots]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    \end{prooftree}

      It's relatively straightforward to see that the branch is infinite:
      we have to continue instantiating
      $\forall x\neg\forall y S(x,y)$
      with the new parameters we introduce,
      then we get a new existential quantifier,
      which forces us to introduce a new parameter,
      \dots---we have a quantifier feedback loop.
      At the same time,
      there is never a non-negated atomic formula on the branch
      (try to find the pattern).
      Our countermodel thus looks like this:
      \begin{itemize}
        \item $D^{\mathcal{M}_{B}}=\{p_{1}, p_{2}, \mathellipsis\}$
        \item $S^{\mathcal{M}_{B}}=\emptyset$
      \end{itemize}

      Here is a finite model that works as countermodel for the same inference:
      \begin{itemize}
        \item $D^{\mathcal{M}_{B}}=\{p_{1}\}$
        \item $S^{\mathcal{M}_{B}}=\emptyset$
      \end{itemize}

  \end{enumerate}

\item[10.8.5] (d)

  \begin{center}
    \begin{prooftree}
      {%
        line numbering=false,
        for tree={s sep'=10mm},
        single branches=true,
        close with=\xmark
      }
      [{\exists x(P(x)\land \forall y(P(y)\to x=y))}, grouped
        [{\neg\forall x\forall y(P(x)\land P(y)\to x=y)}, grouped
          [{P(p)\land \forall y(P(y)\to p=y)}
            [{P(p)}
              [{\forall y(P(y)\to p=y)}
                [{\exists x\neg\forall y(P(x)\land P(y)\to x=y)}
                  [{\neg\forall y(P(q)\land P(y)\to q=y)}
                    [{\exists y\neg (P(q)\land P(y)\to q=y)}
                      [{\neg (P(q)\land P(r)\to q=r)}
                        [{P(q)\land P(r)}
                          [{q\neq r}
                            [{P(q)}
                              [{P(r)}
                                [{P(q)\to p=q}
                                  [{\neg P(q)}, close ]
                                  [{p=q}
                                    [{P(r)\to p=r}
                                      [{\neg P(r)}, close ]
                                      [{p=r}
                                        [{q=r}, close]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    \end{prooftree}
  \end{center}

  \item[10.8.6] The reason why it's not possible to write such an
    algorithm is that it would lead to a decision procedure for
    first-order logic, which we know can't exist. Suppose you could in
    finitely many steps determine whether a formula is invalid, that
    is: false in some model. Now suppose you're wondering if a given
    formula is valid. You run the algorithm. If the algorithm tells
    you the formula is invalid, you know the answer to your question:
    no. If the algorithm tells you the formula is not invalid, well,
    then it must be valid; so you know the answer to your question:
    yes. So, an algorithm that determines invalidity gives an
    algorithm for validity. We know the later doesn't exist, so the
    former can't exist either.

    \emph{Hardcore version}. Also such an algorithm would lead to a
    decision procedure, though in a slightly more complicated
    fashion. Suppose you're interested in whether a formula is valid
    but you can only determine whether it's contingent. First, find
    out whether the formula is contingent. If it is, you know it can't
    be valid, because a contingent formula is false in some model. If
    you find out the formula is not contingent, then there are
    two options: either the formula is true in every model
    or it is false in every model. We need to figure out in which of
    the two cases we are. But we can do this using the algorithm
    again. The way this works is that you pick any contingent formula,
    say a non-trivial identity claim of the form $a=b$. Then you
    consider the \emph{disjunction} of your initial form and that
    contingent formula. Run the algorithm on that statement. If it
    turns out to be contingent, then the initial formula must be false
    in every model. If the disjunction turns out to be non-contingent,
    then the initial formula must be valid. Why so? Well, a disjunction
    is true iff at least one of the disjuncts is true. Now let's go
    through the two possible situations. If the initial formula is
    false in every model, then the disjunction will be true precisely
    in the models where the contingent formula is true---which means
    the disjunction will be itself contingent. But if the initial
    formula was valid, it is true in every model, and so it's
    disjunction with any other statement will also be true in every
    model. So, the disjunction of our non-contingent formula and a
    contingent formula will be non-contingent iff the non-contingent
    formula is valid.
  
\end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../../logic.tex"
%%% End:
